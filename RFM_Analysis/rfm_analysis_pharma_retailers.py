# -*- coding: utf-8 -*-
"""RFM Analysis - Pharma_Retailers.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1njJRU2xc8hsjcdE7ogcqKhGR5yj2Yo3i

**Customer segmentation** is the practice of grouping customers based on common characteristics. These customer segments are beneficial in marketing campaigns, in identifying potentially profitable customers, and in developing customer loyalty. A company might segment customers according to a wide range of factors, including: demographics (age, gender, location etc), behaviour (previous orders, responses to messaging), psychographics (values, interests, lifestyles) etc.

**RFM (Recency-Frequency-Monetary) analysis** is a simple technique for behaviour based customer segmentation. It groups customers based on their transaction history – how recently, how often and how much did they buy. It is a handy method to find the best customers, understand their behavior and then run targeted marketing campaigns to increase sales, satisfaction and customer lifetime value.

The goal of this analysis is to identify customer segments for global retail company using RFM analysis and to understand how those groups differ from each other.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import datetime as dt
import matplotlib.pylab as plt
# %matplotlib inline
from sklearn.cluster import KMeans
from pandas_profiling import ProfileReport

data = pd.read_csv("/content/drive/MyDrive/DS Projects/Project 72/CreditAnalysis_data.csv")

data.head()

data.info()

data.isna().sum() # Product Id is showing 171 null values, which can be ignored as its not an important feature in RFM analysis & considering master_order_id only for Retailer identification

data.duplicated().sum() # there are no duplicte records

data['created'] = pd.to_datetime(data['created'])  # converting to datetime format

data = data[~data['master_order_status'].str.startswith('r')] # removing Cancelled & Rejected from master_order_status and order_status columns
 data = data[~data['master_order_status'].str.startswith('c')]
 data = data[~data['order_status'].str.startswith('r')]
 data = data[~data['order_status'].str.startswith('c')]

data['master_order_status'].unique() # checking all the statuses in the attribute

data['order_status'].unique() # checking all the statuses in the attribute

"""**Calculating Recency**"""

df_recency = data.groupby(by = 'master_order_id',as_index = False)['created','dist_names', 'retailer_names'].max()
df_recency.columns = ['master_order_id','last_purchase_date','dist_names', 'retailer_names']
recent_date = df_recency['last_purchase_date'].max()
df_recency['Recency'] = df_recency['last_purchase_date'].apply(lambda x: (recent_date - x).days)
df_recency.tail()

"""**Calculating Frequency**"""

df_frequency = data.drop_duplicates().groupby(by=['master_order_id'], as_index=False)['created'].count()
df_frequency.columns = ['master_order_id', 'Frequency']

"""**Calculating Monetary Value**"""

df_monetary = data.groupby(by = 'master_order_id', as_index = False)['value'].sum()
df_monetary.columns = ['master_order_id', 'Monetary']

"""**Merging all three columns in one dataframe**"""

df_rf = df_recency.merge(df_frequency, on='master_order_id')
df_rfm = df_rf.merge(df_monetary, on='master_order_id').drop(columns='last_purchase_date')
df_rfm.head()

"""**Ranking Customer’s based upon their recency, frequency, and monetary score**

"""

df_rfm['R_Score'] = pd.qcut(df_rfm['Recency'], 5,[5,4,3,2,1]).astype(int)
df_rfm['F_Score'] = pd.qcut(df_rfm['Frequency'].rank(method="first"), 5,labels=[1,2,3,4,5]).astype(int)
df_rfm['M_Score'] = pd.qcut(df_rfm['Monetary'], 5,[5,4,3,2,1]).astype(int)
df_rfm.head()

# normalizing the rank of the customers
df_rfm['R_Rank'] = (df_rfm['R_Score']/df_rfm['R_Score'].max())*100
df_rfm['F_Rank'] = (df_rfm['F_Score']/df_rfm['F_Score'].max())*100
df_rfm['M_Rank'] = (df_rfm['M_Score']/df_rfm['M_Score'].max())*100

"""**Calculating RFM score**

RFM score is calculated based upon recency, frequency, monetary value normalize ranks. Based upon this score we divide our customers. Here we rate them on a scale of 5. Formula used for calculating rfm score is : 0.15*Recency score + 0.28*Frequency score + 0.57 *Monetary score
"""

df_rfm['RFM_Score'] = 0.15 * df_rfm['R_Rank'] + 0.28 * df_rfm['F_Rank'] + 0.57 * df_rfm['M_Rank']
df_rfm['RFM_Score'] *= 0.05
df_rfm = df_rfm.round(2)
df_rfm.head(7)

df_rfm.shape

df_KMeans = df_rfm.drop(columns = ['dist_names', 'retailer_names'])
df_KMeans.head()

"""**KMeans Clustering**"""

TWSS = []

k = list(range(2,9))

for i in k:
    kmeans = KMeans(n_clusters = i)
    kmeans.fit(df_KMeans)
    TWSS.append(kmeans.inertia_)

    
TWSS
# Scree plot 
plt.plot(k, TWSS, 'ro-');plt.xlabel("No_of_Clusters");plt.ylabel("total_within_SS")

# Selecting 6 clusters from the above scree plot which is the optimum number of clusters 
model = KMeans(n_clusters = 6)
model.fit(df_KMeans)

model.labels_ # getting the labels of clusters assigned to each row 
mb = pd.Series(model.labels_)  # converting numpy array into pandas series object 
df_rfm['Clust'] = mb # creating a  new column and assigning it to new column 
df_rfm.head() # checking 'Clust' column added to 'df_rfm' data

df_rfm.Clust.value_counts() # checking count of each cluster

df_rfm.describe().T # checking statistical dimensions of the data

df_rfm['RFM_Score'].groupby(df_rfm.Clust).mean() # Calculating aggregate mean of each cluster

df_rfm["Customer_Segment"] = np.where(df_rfm["RFM_Score"] > 4.40,"Top Customers", (np.where(df_rfm["RFM_Score"] > 4, "High Value Customers", (np.where(df_rfm["RFM_Score"] > 3, "Medium Value Customers", (np.where(df_rfm["RFM_Score"] > 2.5, "Potential-Medium Customers", (np.where(df_rfm["RFM_Score"] > 2, "Low Value Customers", "Lost Customers")))))))))

df_rfm['Customer_Segment'].value_counts()

df_rfm.to_csv("Retail_Pharma_RFM.csv", index=False, encoding = "utf-8") # Creating csv file of the dataset with clusters column
import os
os.getcwd()

plt.rcParams["figure.figsize"] = [8.00, 5.50]
plt.rcParams["figure.autolayout"] = True
plt.pie(df_rfm.Customer_Segment.value_counts(), pctdistance = 1,
        labels=df_rfm.Customer_Segment.value_counts().index,
        autopct='%.0f%%')
plt.legend(bbox_to_anchor=(0.25,0.50), loc="center right", 
                          bbox_transform=plt.gcf().transFigure),
plt.axis('equal')
plt.show()

"""**Sweetviz : Auto EDA**"""

!pip install sweetviz

import sweetviz as sv

my_report = sv.analyze(df_rfm)
my_report.show_html() # Default arguments will generate to "SWEETVIZ_REPORT.html"

"""**Pycaret : RFM Model**"""

pip install pycaret

from pycaret.classification import *

pip install numpy==1.20.0

import pandas as pd
df_rfm = pd.read_csv("/content/drive/MyDrive/DS Projects/Project 72/Retail_Pharma_RFM.csv")
df_rfm = df_rfm.iloc[:,[0,2,12,14]]
df_rfm.head()

data_py = df_rfm.sample(frac=0.9, random_state=42)
data_unseen = df_rfm.drop(data_py.index)

data_py.reset_index(drop=True, inplace=True)
data_unseen.reset_index(drop=True, inplace=True)

print('Data for Modeling: ' + str(data_py.shape))
print('Unseen Data For Predictions: ' + str(data_unseen.shape))

df1 =  setup(data = data_py, target = 'Customer_Segment',session_id=42)

best = compare_models()

dt = create_model('dt')

print(dt) # As the accuracy is very good, tuning the model is not added

"""**Plot a Model**"""

plot_model(dt, plot = "confusion_matrix")

plot_model(dt, plot = "class_report")

plot_model(dt, plot = "error")

predict_model(dt); # Predict on test

evaluate_model(dt)

"""**Finalize Model for Deployment**

"""

final_dt = finalize_model(dt)

print(final_dt)

"""**Predict on unseen data**"""

unseen_predictions = predict_model(final_dt, data=data_unseen)
unseen_predictions.head()

"""**Saving the model**"""

save_model(final_dt,"final_dt")

"""**Loading the saved model**"""

model = load_model("final_dt")

"""**Predicting on the new data**"""

new_prediction = predict_model(model, data=data_unseen)

new_prediction.head() # the results of unseen_predictions and new_prediction are identical

import pickle

filename = 'trained_model.sav'
pickle.dump(final_dt,open(filename, wb))

"""# **Streamlit Deployment**"""

pip install streamlit

from pycaret.classification import load_model, predict_model
import streamlit as st
import pandas as pd
import numpy as np
model = load_model('final_dt')
import plotly.express as px
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import matplotlib.pyplot as plt

st.title("Customer-Segmentation based on RFM Scores for Pharma Retailers")
st.markdown('The dashboard will visualize the Customer-Segments of Pharma Retailers')
st.markdown('**RFM (Recency-Frequency-Monetary) analysis** is a simple technique for behaviour based customer segmentation')
st.sidebar.title("Visualization Selector")
st.sidebar.markdown("Select the Charts/Plots accordingly:")

# C:\Users\Karuna Singh\OneDrive\360\DS_Projects\Project 72\Code Files\rfm_analysis_pharma_retailers

select = st.sidebar.selectbox('Visualization type', ['Bar plot', 'Pie chart'], key='1')
if not st.sidebar.checkbox("Hide", True, key='1'):
     if select == 'Pie chart':
                         st.title("Top 5 Retailers")
                         fig=px.pie(df, values=df_rfm['retailer_names'][:5], names=df_rfm['RFM_Score'][:5], title='Top 5 Retailers')
                         st.plotly_chart(fig)
                         
                         if select=='Bar plot':
                           st.title("Selected Top 5 Retailers")
                           fig = go.Figure(data=[
        go.Bar(name='Recency', x=df_rfm['reailers_names'][:5], y=df['Recency'][:5]),
        go.Bar(name='Frequency', x=df_rfm['retailer_names'][:5], y=df['Frequency'][:5]),
        go.Bar(name='Monetary', x=df_rfm['retailer_names'][:5], y=df['Monetary'][:5])])
                           st.plotly_chart(fig)

def predict(model, input_df):
    predictions_df = predict_model(estimator=model, data=input_df)
    predictions = predictions_df['Label'][0]
    return predictions

def run():
    from PIL import Image
    image = Image.open('Customer Lifetime Value.png')
    image_pharmacy = Image.open('Pharmacy.jpg')
    st.image(image,use_column_width=False)
    add_selectbox = st.sidebar.selectbox(
    "How would you like to predict?",
    ("Online", "Batch"))
    st.sidebar.info('This app is created to predict if an employee will leave the company')
    st.sidebar.success('https://www.pycaret.org')
    st.sidebar.image(image_pharmacy)
    st.title("Predicting Pharma Retailers Segment")
    
    if add_selectbox == 'Online':
      master_order_id =st.text_input("Enter Master Order Id")
      retailer_names =st.text_input('Enter Retailer Name')
      RFM_Score = st.text_input('RFM_Score')
      Customer_Segment=""
      input_dict={'master_order_id':master_order_id, 'retailer_names':retailer_names,'RFM_Score':RFM_Score,'Customer_Segment':Customer_Segment}
      input_df = pd.DataFrame([input_dict])
      
      if st.button("Predict"):
        Customer_Segment = predict(model=model, input_df=input_df)
        Customer_Segment = str(Customer_Segment)
        st.success('The output is {}'.format(Customer_Segment))

      if add_selectbox == 'Batch':
        file_upload = st.file_uploader("Upload csv file for predictions", type=["csv"])
        if file_upload is not None:
            data = pd.read_csv(file_upload)
            predictions = predict_model(estimator=model,data=data)
            st.write(predictions)